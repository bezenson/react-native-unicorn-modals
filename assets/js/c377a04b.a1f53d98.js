"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[971],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(n),m=a,h=d["".concat(s,".").concat(m)]||d[m]||u[m]||o;return n?r.createElement(h,i(i({ref:t},p),{},{components:n})):r.createElement(h,i({ref:t},p))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:a,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},917:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>m,frontMatter:()=>l,metadata:()=>c,toc:()=>d});var r=n(7462),a=n(7294),o=n(3905);const i=e=>{let{children:t,to:n}=e;return a.createElement("a",{href:n,className:"button button--primary button--lg",target:"_blank"},t)},l={sidebar_position:1},s="Introduction",c={unversionedId:"index",id:"index",title:"Introduction",description:"This library is under development now. API can change.",source:"@site/docs/index.md",sourceDirName:".",slug:"/",permalink:"/react-native-unicorn-modals/docs/",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",next:{title:"Quick Start",permalink:"/react-native-unicorn-modals/docs/guides/quick-start"}},p={},d=[],u={toc:d};function m(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"introduction"},"Introduction"),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"This library is under development now. API can change.")),(0,o.kt)("p",null,"Every time I have to work with modal windows in React Native, I encounter different problems."),(0,o.kt)("p",null,"If we talk about the standard ",(0,o.kt)("inlineCode",{parentName:"p"},"Alert")," from React Native, it is poorly configurable and has a different look on different platforms. Often this does not match the main design of the application. But this approach has one advantage - simple usage via imperative API."),(0,o.kt)("p",null,"If the functionality of standard ",(0,o.kt)("inlineCode",{parentName:"p"},"Alert")," is not enough, then you have to use third-party libraries to implement your own modal window. In my opinion most of libraries has one disadvantage - declarative approach. First you need to describe the modal window in JSX, then set its state and implement that state control. And what if you need to show several modal windows one after another? We usually put them on each other, which negatively affects the appearance of the application. These problems have to be solved literally in every application."),(0,o.kt)("p",null,"I had an idea to write a small library that would meet certain requirements:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Imperative approach"),". The standard AlertAPI is great: all windows have a standard look and are easily configured using arguments passed to the function call. It formed the basis of this library."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Easy change of appearance"),". Today, applications often have the ability to switch between light and dark modes."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Components should not overlap each other"),". Animations should be simple and smooth. The next modal window should not be shown until the previous one is closed and even more so cover it."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"An infinite number of components"),". Just think of this library as a small framework. I did not want to limit developers to just Alert. There are two ready-to-use components in the library - Alert and Menu. However, you can implement any other own component.")),(0,o.kt)("p",{align:"center"},(0,o.kt)(i,{to:"https://snack.expo.dev/@inferusvv/react-native-unicorn-modals",mdxType:"ButtonLink"},"Expo Snack Demo App")),(0,o.kt)("p",{align:"center"},(0,o.kt)("img",{src:"img/demo.gif",height:"500"})))}m.isMDXComponent=!0}}]);